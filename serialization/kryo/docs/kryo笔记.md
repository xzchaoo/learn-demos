# 介绍 #
目前是Java的最快的几个序列化框架之一

# 特性 #

1. 保持类型信息, 序列化之前和反序列化之后的类型是一样的
2. 支持引用关系, 同一个引用只会被序列化1次, 反序列化之后的序列化关系依旧
3. 深浅复制


# 序列化器 #

## Field ##
这是Kryo的默认序列化器, 它的实现方式是, 将类的所有字段按顺序进行输出, 只会输出字段值, 不会有类似PB的序号, 因此效率是非常高的.  
但是这种方式几乎没有任何兼容性, 添加和删除字段都会产生不兼容, 建议用于可丢失性的缓存.

## TagField ##
这个工作方式和PB类似, 会输出每个字段的序号和值, 需要给所有需要序列化的字段加上@Tag注解, 否则字段不会进行序列化.  
为了保持向前兼容和向后兼容, 比如启动 "忽略未知字段" 以及, 新增的字段需要添加 annexed = true  

增删字段可兼容.

## Version ##
新增的字段需要添加 @Since 注解, 接受一个int参数表示版本, 表示这个字段自从这个版本之后可用

TODO 增删字段兼容性待测试.

## 自定义序列化器 ##
还是蛮直接的, 实现序列化器接口的2个方法, 并且注册序列化器就行了.

# 获取序列化器 #
介绍一下顺序

# register #
序列化对象时, 当第一次遇到某个类, 就会为这个类生成一个int值, 然后建立该类与int的映射关系, 类名会输出到序列化结果里, 在本次序列化过程中, 如果这个类再次遇到, 那么就用该int代替.  
反序列化的时候就会利用这个int值来判断类型.  
Kryo提供了regsiter可以提前注册一些类, 其实这是讲上述的步骤给提前了而已, 这样类全名就不会出现在序列化结果里, 节省了空间, 提高了效率.  
但是这个操作挺危险的, 因为一定要保证序列化方和反序列化方的类的id是一样的, 否则会导致反序列化失败.

> 如果改变了register的调用顺序, 会导致id不一样, 从而导致不兼容

# 深浅复制 #
Kryo 深知如何创建和遍历一个对象, 因此它可以顺便用来做深浅复制

# Chunk #
序列化某些数据的时候, 我们可能需要提前知道序列化后的字节长度, 但如果不先去序列化, 我们是不知道大小的. 这就产生了一个矛盾, 为了避免在内存里持有比较大的buffer, 可以采用chunked策略.  
每次写一个固定大小的chunked块, 最后一块不满大小不要紧, 以一个大小为0的chunked块作为结束

这也是支持向前兼容的必要条件, 否则的话你无法知道某个字段是否已经输出结束了.  
那为何PB就没有这种问题呢? 其实PB, 其实PB不支持流式输出(Stream), 其实内部只能用字节数组来做, 因此数据长度都是事先算好的



# 杂 #


# 注意事项 #
1. Kryo会保证序列化钱和反序列化后的类型是完全一致的, 举个例子: 如果序列化之前是LinkedList, 那么反序列化之后也是一个LinkedList. 这看似是一个挺好的特性, 但是很多时候会导致反序列化失败.
2. Input和Output要配套使用, 否则反序列化失败
3. 如果使用KryoPool来实现Kryo的复用, 那么需要尽量避免拿到Kryo之后修改Kryo的属性

# 参考资料 #
https://github.com/EsotericSoftware/kryo/
https://blog.csdn.net/fanjunjaden/article/details/72823866
